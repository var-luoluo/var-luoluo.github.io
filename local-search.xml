<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Arch 小药盒</title>
    <link href="/2024/03/arch-media-box/"/>
    <url>/2024/03/arch-media-box/</url>
    
    <content type="html"><![CDATA[<h1 id="Arch-小药盒"><a href="#Arch-小药盒" class="headerlink" title="Arch 小药盒"></a>Arch 小药盒</h1><p>文件来自开源项目 <a href="https://github.com/Isoheptane/arch-media-box">arch-media-box</a></p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/arch/arch_3.webp" alt="图片-1"></p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/arch/arch_2.webp" alt="图片-2"></p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/arch/arch_1.webp" alt="图片-3"></p>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
      <tag>arch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地资源管理方案 -- 图片篇</title>
    <link href="/2024/03/manger-pictures/"/>
    <url>/2024/03/manger-pictures/</url>
    
    <content type="html"><![CDATA[<h1 id="本地资源管理方案-–-图片篇"><a href="#本地资源管理方案-–-图片篇" class="headerlink" title="本地资源管理方案 – 图片篇"></a>本地资源管理方案 – 图片篇</h1><p>图片分类：</p><ul><li>壁纸</li><li>MeMe</li><li>照片</li><li>表情包</li><li>动漫图</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2>]]></content>
    
    
    
    <tags>
      
      <tag>管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地资源管理方案 -- 书籍篇</title>
    <link href="/2024/03/manger-books/"/>
    <url>/2024/03/manger-books/</url>
    
    <content type="html"><![CDATA[<h1 id="本地资源管理方案-–-书籍篇"><a href="#本地资源管理方案-–-书籍篇" class="headerlink" title="本地资源管理方案 – 书籍篇"></a>本地资源管理方案 – 书籍篇</h1><p>书籍分类：</p><ul><li>电子书</li><li>漫画</li><li>杂志</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2>]]></content>
    
    
    
    <tags>
      
      <tag>管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地资源管理方案 -- 音乐篇</title>
    <link href="/2024/03/manager-musics/"/>
    <url>/2024/03/manager-musics/</url>
    
    <content type="html"><![CDATA[<h1 id="本地资源管理方案-–-音乐篇"><a href="#本地资源管理方案-–-音乐篇" class="headerlink" title="本地资源管理方案 – 音乐篇"></a>本地资源管理方案 – 音乐篇</h1><p>音乐分类：</p><ul><li>专辑</li><li>纯音乐</li><li>歌单</li><li>杂项</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2>]]></content>
    
    
    
    <tags>
      
      <tag>管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hi docker</title>
    <link href="/2024/03/hi-docker/"/>
    <url>/2024/03/hi-docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Hi-docker"><a href="#Hi-docker" class="headerlink" title="Hi docker~"></a>Hi docker~</h1><blockquote><p>本文章仅面对非专业人员，以便于使用docker的最基本功能，不会涉及太多原理与命令</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/walkxcode/dashboard-icons/png/docker-moby.png" alt="docker"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在本篇文章中，我们会暂时放弃某些概念的严谨性，以便于理解，同时我们会在合适的地方指出这些不严谨，这可能看起来会很啰嗦。不过不必太在意这些不严谨，它并不影响你现阶段的正常理解和使用。</p><p><del>以及，我写东西的语言风格比较奇怪，看起来像是翻译生硬的外文课本，emmm，大抵如此</del></p><p>在这篇文章中，你将会看到:</p><ul><li>docker原理笼统的解释；</li><li>Windows系统下,docker desktop桌面软件的安装和详细配置；</li><li>docker中基本概念的解释；</li><li><del>如何处理docker的网络问题；</del></li><li>docker命令的不详细解释；</li><li>常见docker容器的部署案例；</li><li>如何获取需要的compose文件；</li><li>如何简单修改compose文件；</li></ul><p>你不会看到:</p><ul><li><del>docker原理细致的介绍；</del></li><li><del>类Unix系统的docker安装；</del></li><li><del>使用docker run运行docker容器；</del></li><li><del>如何自己编写compose文件；</del></li><li><del>如何自己编写Dockerfile；</del></li><li><del>K8s以及其它相关技术；</del></li></ul><p>以及，我们推荐你阅读&#x2F;观看：</p><p>视频：<a href="https://www.bilibili.com/video/BV1s54y1n7Ev">Docker 10分钟快速入门</a></p><p>文字：<a href="https://yeasy.gitbook.io/docker_practice">Docker – 从入门到实践</a></p><p>相对来说，视频更简单易懂但是包含的信息密度低；文字稍微复杂一点但是同样时间下同样质量的内容，文字所提供的信息更多。不过我这篇写的比较水。</p><p>最后，如果你想要真正理解<code>docker</code>的底层实现，这里有个完美的视频，胜过国内千千万万互相抄袭的文章，Grace!</p><p><a href="https://www.youtube.com/watch?v=8fi7uSYlOdc">https://www.youtube.com/watch?v=8fi7uSYlOdc</a></p><h2 id="所以，什么是docker"><a href="#所以，什么是docker" class="headerlink" title="所以，什么是docker"></a>所以，什么是docker</h2><p>首先需要明确的是，<code>docker</code> 是一系列概念的代表：它可能代表着一家公司，一项技术，一个软件甚至是某种符号。</p><p>本篇文章涉及概念的时候，我们将其视为一项技术，即容器管理技术。<br>而到实际的安装、使用过程中，它代表着运行在操作系统上的一款软件。</p><p>所以，我们说，<code>docker</code>是一项容器管理技术；这里出现了新的概念-–容器。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>想象一下一个运行在操作系统中的本地图片查看器，它大概率不会需要使用网络服务，也不会用到声卡……对于一个完整的操作系统，它不会使用其提供的绝大部分的功能。(不过下面这个需要网络服务…)</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/newimage.webp" alt="KDE社区开源软件--digiKam"></p><p>现在我们考虑将这个程序独立出来：将该应用程序和其依赖的环境(比如文件的IO、交互逻辑等)以某种方式打包，就构成了一个<strong>容器</strong>。即<strong>容器</strong>是<u>特定的程序及其依赖的运行环境组成的</u>，我们称呼这个整体为一个<strong>容器</strong>。这个整体比单独的软件大，但比一整个操作系统小的多。</p><p><code>docker</code> 技术可以使这些容器以独立的形式运行在操作系统上（你可以理解为，docker“欺骗”了进程，让他以为自己是独立在一个系统之上的），这听起来有些奇怪，将程序和依赖环境打包，最终不还是要运行在操作系统上?</p><p>是的，这听起来似乎很蠢，但这样做有一个好处：容器<strong>不再依赖</strong>特定的<strong>外部环境</strong>(这里是不依赖环境而非不依赖系统，windows系统还是无法直接运行linux程序)，只要容器内部环境安排好了，只要系统内核支持，放到任何机器上都可以直接运行而不用担心因为环境的不同导致的程序运行差异，因为所有的依赖都已经被打包，对该进程而已已经不需要任何其它外部环境的支持了(当然内核肯定是需要的)；</p><p>这里你应该能知道为何开发和运维人员需要掌握<code>docker/容器</code>技术了，因为它极大的便利了应用程序的部署和维护，将人们从繁琐的环境部署中解放出来，一次配置，处处运行。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018020901.png" alt="随手偷来的图"></p><p>另外一个好处就是，容器独立于当前的文件系统，它不会影响你对操作系统的正常使用，同时也让同名应用程序可以不受限制的同时运行；</p><p>至于为什么可以独立于当前的使用，这得益于Linux内核所提供的命名空间(以及控制组)特性，简单理解为一个全新的用户和你一起使用了这个操作系统(他甚至可以拥有与你相同的用户标识)，他和你共同享用系统的资源，同时使用独立的用户空间，和你以及你的文件并无直接交互。</p><p>这样解释应该比较容易理解容器概念了，而<code>docker</code>则是为管理容器而创造的。不过我们不需要去了解<code>docker</code>如何在容器和系统内核之间进行通信，这不在本文讨论范围，重要的是容器这个概念而非<code>docker</code>，很多人将<code>docker</code>等同于容器(实际上本文也在很多地方混用这个概念)，这是非常错误的，<code>docker</code>是管理容器的一系列技术的一种实现。</p><p>不可否认<code>docker</code>对容器技术的发展起到了巨大的作用，但这里我们必须阐明二者的绝对不同。实际上还有相当多的容器管理(编排)技术组，比如<code>podman</code>、<code>K8s</code>……</p><p>另外，在和谷歌<code>k8s</code>的皇城pk中,<code>docker</code>落得满盘皆输，早已不复往日霸主地位……当然，如果仅做个人或者说入门使用，业界老前辈<code>docker</code>仍然是最好的选择，我们也以此为基础介绍相关技术，它足够简单，兼容性强，拥有图形化界面，同时拥有丰富的社区支持。</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/Docker-vs-Kubernetes_980x533_5.webp" alt="docker vs k8s"></p><p>最后需要指出的是，上述的描述仍有不是那么严谨的部分，譬如Windows内核同样支持容器技术，以及docker并不完全依赖Linux，它虽然从LXC起家，但是后续发展了自己的技术。不过这些并不影响你对容器的认识和接下来对<code>docker</code>的使用，我们不希望因为一些太过繁琐的概念或是理论影响你对问题本质的理解；</p><p><img src="https://www.redhat.com/rhdc/managed-files/traditional-linux-containers-vs-docker_0.png" alt="传统 linux 容器 vs Docker"></p><h3 id="容器和虚拟化技术"><a href="#容器和虚拟化技术" class="headerlink" title="容器和虚拟化技术"></a>容器和虚拟化技术</h3><p>如果你阅读过其他的教程或文章，就会发现作为另一种虚拟化技术，虚拟机通常会拿来同容器进行对比。</p><p>和容器不同，虚拟机模拟了完整的操作系统，同时包括硬件资源，所占据的系统资源相较于容器多了几个量级。当然虚拟机有其独有的应用范围，我们无意进行指摘。</p><p>实际上在Windows系统和MacOS系统上使用<code>docker</code>，就需要借助虚拟机(一般情况是这样，不过windows也支持windows容器，开启需要一定条件，不推荐个人使用，<del>另外水果真吸血鬼</del>，我对Windows容器所知甚少)，这是因为容器技术依赖于linux内核的几个特性，这在前文稍有提及。</p><p>先由系统模拟出一个linux环境,然后再由<code>docker</code>程序在这个虚拟机上运行所指定的容器。不过不用担心虚拟机的问题，<code>docker</code>软件在安装时会自动处理关于虚拟机的问题。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-6864425/f9ffd92001a41ff101e70dab550e3974.jpeg" alt="软件交付方式的发展"></p><p>在这里我们多提一下，容器作为成熟的虚拟化技术，并非一个新概念。实际上早在Unix系统诞生之时，先驱们就已经开始考虑隔离进程，使用<code>chroot</code>系统调用来分配虚拟文件系统；比较清晰的使用发布于FreeBSD，随后linux开始进行内核级的支持并逐渐发展，而后docker由其易用性将其彻底引爆，接着就是docker和谷歌干架，跌落神坛，最终形成了今天如此繁盛开放的容器技术。</p><h2 id="安装-Docker-desktop"><a href="#安装-Docker-desktop" class="headerlink" title="安装 Docker desktop"></a>安装 Docker desktop</h2><p><code>Docker Desktop</code> 是<code>docker</code>在windows下的图型管理工具，他能便捷的下载，控制和销毁容器；<br>提供丰富的操作选项,同时监控容器对各类系统资源的占用;</p><p>在Windows上安装 <code>Docker desktop</code> 是一件很容易的事情，安装程序会帮你妥善处理好依赖问题，如果需要更详细的安装指导或者错误诊断，请参考 <a href="https://docs.docker.com/desktop/install/windows-install/">docker官方文档</a>、<a href="https://learn.microsoft.com/zh-cn/virtualization/windowscontainers/manage-docker/configure-docker-daemon#install-docker">windows官方文档</a> 或是一个稍微有些 <a href="https://www.runoob.com/docker/windows-docker-install.html">老旧的中文指南</a></p><p>下面是我本机安装的过程</p><h3 id="从官网安装"><a href="#从官网安装" class="headerlink" title="从官网安装"></a>从官网安装</h3><p>我们十分推荐你直接使用官网的安装程序来安装<code>Docker Desktop</code>，它会帮你处理好虚拟机等配置。</p><p><a href="https://docs.docker.com/desktop/install/windows-install/">官网下载指导页面</a>，直接下载exe安装就行，出错了再看它标注的信息；</p><p>注意<code>Docker Desktop</code>对系统版本有要求，具体限制在官网有详细标注，一般来说正常使用的Windows 10、11 都可以顺利安装，如果失败，请根据错误信息核对系统版本，考虑升级；</p><p>安装非常简单，和其他软件没有区别，它会帮你开启 <code>WSL</code> 并进行后续的操作；</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image.webp" alt="安装界面"></p><p>安装需要一定的时间…请耐心等待</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-1.webp" alt="完成安装"></p><p>安装完成后，docker会添加开机启动，并注册一些服务，如果不需要，请手动关闭(软件内也可以关闭)，当然如果是否禁止开机启动看个人需求<del>，我一般不在Windows上用docker</del>。</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-2.webp" alt="禁止开机启动"></p><h3 id="启动Docker"><a href="#启动Docker" class="headerlink" title="启动Docker"></a>启动Docker</h3><p>安装之后如果没有自动启动，<del>就手动；</del></p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-4.webp" alt="docker 状态栏图标"></p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-3.webp" alt="docker 数据传输与隐私"></p><p>接受该请求并回答一些调查问题，在询问是否登录时，可以选择不登录直接进入，然后进入 <code>Docker Desktop</code> 页面(我这里是卸载再安装的，配置文件没删完，一些提示我看不到了)，下面是最基本的 <code>Docker Desktop</code> 界面：</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-5.webp" alt="docker desktop 主页面"></p><p>大多数情况下，你只需要使用左边的 <code>Containers</code> <code>Images</code> 这两个按钮，偶尔会用到 <code>Volumes</code>。此外，我无意将本文发展成一篇过于琐碎的说明，所以关于其他部分便不在赘述；</p><h3 id="设置镜像仓库"><a href="#设置镜像仓库" class="headerlink" title="设置镜像仓库"></a>设置镜像仓库</h3><p>当然国内访问 <code>docker</code> 默认的服务器肯定会遇到网络问题，桌面软件的话我们可以设置镜像仓库</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-8.webp" alt="更换默认镜像仓库"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"># 注意用<span class="hljs-punctuation">,</span>分隔json的键值对以避免语法错误<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;https://mirror.baidubce.com&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>设置完之后点击 <code>Apply &amp; restart</code>；<del>有时候它不生效，这是很蠢的事，请退出然后再打开</del>……</p><h2 id="使用-Docker-Desktop"><a href="#使用-Docker-Desktop" class="headerlink" title="使用 Docker Desktop"></a>使用 Docker Desktop</h2><h3 id="Docker概念"><a href="#Docker概念" class="headerlink" title="Docker概念"></a>Docker概念</h3><p>在前面我们说过，<code>docker</code>是来管理容器的，所谓容器就是应用程序和它所依赖的环境的组合；</p><p>而实际应用中，<code>docker</code>对容器技术的实现由 动态容器、静态镜像和远程仓库 三者组成；</p><p>这三者也就是<code>docker</code>中最基本的概念 <code>Containers</code> <code>Images</code> 和 <code>Repository</code></p><p>所以在软件左上角，我们可以看到</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-20240319215430148.webp" alt="左上角显示"></p><p><code>Containers</code>，它代表了动态的容器；<br><code>Images</code>，它代表了静态的镜像；<br>至于 <code>Repository</code> 也就是托管镜像的仓库，它在 <code>docker desktop</code> 被默认了(实际上已经在前面设置中被我们更换了，它默认使用 <a href="https://hub.docker.com/">docker hub</a> )</p><p>所谓动态的容器，就是指运行着的程序与依赖环境(文件系统、环境变量等)，这些整体构成了一个容器。其实质是特殊的进程，容器内部是一个同宿主隔离的环境；<code>Containers</code> 后续我们称呼它为容器；</p><p>所谓静态的镜像，指的是生成容器的一个模板，它标注了目标容器所需要的环境、资源，是对这些内容的一个特殊打包；<code>Images</code> 后续我们称呼它为镜像；</p><p>存放镜像文件的地方，也是我们获取镜像的地方，就是仓库，这是一个非常容易理解的概念，<code>Repository</code> 后续我们称呼它为仓库，它通常是一个或几个中心服务器。</p><p>现在我们来梳理一下容器和镜像的关系：</p><p>镜像是一个标准，标注了某个容器的环境(文件系统、环境变量等)，其本身是静态的，当被创建之后便不再发生任何改变；可以被下载、删除、上传；(当然你也可以制作自己的镜像)</p><p>容器则是镜像的标准的实现，是实际运行的程序，在概念上是动态的，可以被创建、启动、暂停、销毁；</p><p>从镜像文件生成容器，就如同用安装包安装软件一样，只不过这个软件是一个容器；<del>有点类实例化的意思，不过这么说不恰当</del></p><p><img src="http://img.blog.itpub.net/blog/2024/03/05/15d7fe7c9e8d8355.jpeg?x-oss-process=style/bb" alt="随手偷来的图"></p><h3 id="运行nginx容器"><a href="#运行nginx容器" class="headerlink" title="运行nginx容器"></a>运行nginx容器</h3><p>在了解完概念之后，让我们实际体验一下。</p><p>点击左侧的 <code>Images</code>，可以看到大大的 <em>Search images to run</em>，提示我们可以搜索并下载需要的镜像；</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-6.webp" alt="搜索镜像提示"></p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-7.webp" alt="搜索框"></p><p>这里我们选择下载它推荐的第一个 <code>nginx</code>(这是一个网络服务器，用于部署网页)</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-9.webp" alt="搜索nginx镜像"></p><p>速度有点迷~~~如果你搜索没有看到任何内容，且正确更换了镜像仓库，可以重新启动软件试试，，，~~</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-11.webp" alt="浏览已安装的镜像"></p><p>这样我们获得了 <code>nginx</code> 的镜像文件，可以看到他的一些信息，比如名字、Tag(版本)、使用状态，创建时间，文件大小，以及Action；现在我们通过这个镜像运行一个容器，在Actions里点击开始符号<code>Run</code></p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-12.webp" alt="容器参数设置"></p><p>我们需要给容器一些特殊的参数信息，只有名字是必须的，用来区分不同的容器；(不手动设置，就会分配一个随机的)</p><p>但是特殊的容器需要特殊的设置，比如 <code>nginx</code> 通过80端口展示页面，我们在 <code>Ports</code> 里需要给他指定一个端口，这个端口是我们外部的端口，我们从这个端口连通容器内部的80端口；如果你不知道端口号的含义，可以设置为 8081 端口(它通常用作web测试，前提是你的设备没有进程占用该端口)，如果有占用可以往后推 8082 …</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-13.webp" alt="随手打了个8888…"></p><p>本地系统可能会有防火墙提醒，这是由于<code>docker</code>希望通过本机的端口通讯，请允许它；</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-14.webp" alt="防火墙提醒"></p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-15.webp" alt="Nginx 日志页面"></p><p>然后该镜像就会运行出一个容器，名字为你设定的，其80端口被映射到本机8081端口，你可以通过 <a href="http://localhost:8081/">http://localhost:8081/</a> 来访问该容器的服务</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-16.webp" alt="成功启动nginx容器"></p><p>可以看到 <code>nginx</code> 服务已经正常启动；现在让我们开始查看该容器的信息·</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-18.webp" alt="浏览已部署的容器"></p><p>我们可以看到它的名字、镜像、状态、CPU占用、端口号映射、以及 Action；</p><p>Action 主要就是控制该容器，可以暂停、启动、删除(需先暂停容器)，还可以查看容器的各类信息</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-19.webp" alt="Action 选项"></p><p>如果你对计算机程序控制了解不多，可以不用在意容器里面的细节，优秀的镜像创建者应当为用户提供合适的控制接口，直接进入容器内部控制显然是不明智的(emmm)</p><h3 id="一个更友好的例子"><a href="#一个更友好的例子" class="headerlink" title="一个更友好的例子"></a>一个更友好的例子</h3><p><code>nginx</code> 是非常强大的web服务器，但在这里并不是一个好的例子，因为展示网页需要一定的配置以及web文件；</p><p>对个人来说，使用 <code>docker</code> 更大的目的是为了一键部署自己想要的程序而不必了解其部署细节；所以我们现在用一个更加友好的，<a href="https://alist.nn.ci/">alist</a></p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-20.webp" alt="搜索alist镜像"></p><p><del>不得不说，docker desktop的搜索和下载真是感人，我确定我的网络配置没问题，结果还是一会快一会慢</del></p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-21.webp" alt="alist和nginx镜像"></p><p>这里我们直接使用随机配置，它会分配一个随机的name和随机的映射端口号</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-22.webp" alt="使用随机配置"></p><p>在 <code>Logs</code> 也就是日志信息里，我们看到服务已经启动，也看到了初始的admin和密码，我们通过它给的端口号进行本地访问 </p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-25.webp" alt="alist容器的logs页面"></p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-26.webp" alt="本机访问5244端口"></p><p>显然，<code>alist</code>接下来的配置就可以在web页面里进行了；而在 <code>Containers</code> 页面，我们可以任意控制容器的开关</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-27.webp" alt="容器页面"></p><h3 id="一个不那么友好的例子"><a href="#一个不那么友好的例子" class="headerlink" title="一个不那么友好的例子"></a>一个不那么友好的例子</h3><p>实际上，<a href="https://hub.docker.com/">docker hub</a>上存储着数量惊人的镜像，因为镜像的制作十分简单，我们完全可以给自己的程序打包一个<code>docker</code>镜像，然后上传docker hub或是其他镜像仓库，以方便在任意地方拉取该镜像(上传不是必须的，只要有镜像文件我们就可以部署容器)；</p><p>所以你可以找到大量程序的docker镜像(毕竟系统都能打包)，而且不需要了解它是如何编译如何部署的，只要镜像的制作者足够贴心，你完全可以绕过这些细节，仅作简单的参数配置就可以轻松使用一些很难部署的项目；</p><p>而有时，你只是单纯需要一个外部的环境，来执行一些小脚本，但又不想使用服务器，那<code>docker</code>同样可以作为你的选择，只不过需要你自己去制作一下镜像，这并非一件困难的事情；</p><p><del>这里我列举一个不那么友好的例子，来展示一下：部署的是一个我写的 <a href="https://github.com/var-luoluo/upload-bot">telegram bot</a>，它可以实现本地文件的上传任务，特别是当你的服务器受限于硬盘大小且没有意愿扩容的时候，也许本地部署容器是一个不错的选择。</del></p><p>Wait …</p><h2 id="通过命令行控制-docker"><a href="#通过命令行控制-docker" class="headerlink" title="通过命令行控制 docker"></a>通过命令行控制 docker</h2><p>通过图形化的操作，我们似乎很容易部署一个容器，但是相比于命令行，图形化弱爆了。</p><p>图形操作有太多的局限：需要手动拉取镜像、手动设置参数，交互界面丑陋且毫无补全可用… 最重要的是，它没法借鉴他人的智慧，操作都是点点点.…..而使用命令操作<code>docker</code>，才能真正实现一键部署：把别人写好的文件copy一下，有时候都不用改，直接就能享受服务了。</p><p>在前面我们说过，不会涉及太多的命令，所以有关上述点点点操作的命令替代，比如</p><table><thead><tr><th>任务</th><th>命令</th></tr></thead><tbody><tr><td>拉取镜像</td><td>docker pull nginx</td></tr><tr><td>从镜像启动容器</td><td>docker run –name nginx -p 80:80 -d Nginx</td></tr><tr><td></td><td>-p 指定端口映射，前面的是本机的；-d 命名容器</td></tr><tr><td>停止镜像</td><td>docker stop nginx</td></tr><tr><td>。。。</td><td>docker help</td></tr></tbody></table><p>等等，这些都比较浅显易懂，且有图像操作与之对应，我们就不再展开了，请自行了解。但是，真正的懒人神器 <code>docker compose</code> 不容错过</p><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h3><p><code>Compose</code> 是容器集群编排工具，也就是管理多个容器交互的工具。不过现在我们并不使用它交互容器，而仅仅作为一个快速启动容器的工具。(当然如果涉及到数据库容器，就需要容器之间的交互，不过现阶段我们不会手动写这些配置，直接抄别人的)</p><p><code>docker compose</code> 通过读取配置文件<code>docker-compose.yml</code>，来完成上述的拉取镜像、启动容器、设置参数等行为；</p><p>对任何服务，我们只需要 <code>docker compose up -d</code>(需要配置文件docker-compose.yml在当前目录下，-d的意思是后台运行，不会占据shell前台的io)就直接启动容器了，关闭也只需要 <code>docker compose down</code></p><p><del>至于 <code>docker-compose.yml</code> 怎么写，本文不会涉及；</del></p><p>一般的，如果项目提供了docker镜像，它也会提供一份 compose 配置，复制粘贴然后 <code>docker compose up -d</code> 容器就在后台启动了~</p><p>比如 <code>alist</code> 提供的(volumes需要说明一下，这是挂载本地文件到容器环境的，由此实现二者的文件共享，前面的是自己的文件目录，后面的是容器里的)</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-28.webp" alt="alist compose 示意"></p><p>万一没提供，热心的网友总会替你解决，比如这个</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-29.webp" alt="中文搜索示例"></p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-30.webp" alt="英文搜索更方便"></p><p>最后，真没人写，那就自己动手吧，compose的配置相对来说不是那么难，如果不涉及多个程序交互的情况下(实际上大规模的分布式容器集群多使用<code>K8s</code>管理)</p><h3 id="使用compose部署案例"><a href="#使用compose部署案例" class="headerlink" title="使用compose部署案例"></a>使用compose部署案例</h3><p>在部署之前我们需要补充一下有关于<code>volumes</code>也就是数据卷的概念。</p><p>在前面我们说了，容器独立于当前的环境并不与你的文件系统进行交互，但是有些情况下我们希望同容器共享某些文件，双方都可以写入、读取；同时当容器关闭或者销毁时，共享的文件数据可以一直保留，随时复用。</p><p><code>volumes</code>就是为此而生的，你可以在桌面软件左上角看到它的身影，不过这里我们不再使用图形界面了。在compose配置文件里可以直接指定，本机的某个文件夹挂载到容器的哪个位置。具体操作在后面会有展示。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>首先，我们在合适的位置新建一个<code>Docker</code>文件夹，用来存储我们所有docker配置：</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/newimage-1.webp" alt="文件夹展示"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 推荐使用终端命令来进行操作</span><br><br><span class="hljs-comment"># 当前目录下，新建文件夹 make directory</span><br>mkdir name<span class="hljs-literal">-of-directory</span><br>mkdir Docker<br><br><span class="hljs-comment"># 进入文件夹 change directory</span><br><span class="hljs-built_in">cd</span> path<span class="hljs-literal">-of-directory</span><br><span class="hljs-built_in">cd</span> Docker<br><br><span class="hljs-comment"># 当前目录下，新建文件</span><br><span class="hljs-comment"># ni是New-Item的缩写，它也可以创建文件夹，但是默认创建文件</span><br><span class="hljs-built_in">ni</span> name<span class="hljs-literal">-of-file</span>.extension <span class="hljs-comment"># ni是powershell特有的命令，在cmd中无法运行</span><br><span class="hljs-built_in">ni</span> docker<span class="hljs-literal">-compose</span>.yml<br><br><span class="hljs-comment"># 快速打开文件</span><br><span class="hljs-comment"># 如果你有自己习惯的文本编辑器，请随意</span><br><span class="hljs-comment"># 这里只是缺省一个最基本的</span><br>notepad docker<span class="hljs-literal">-compose</span>.yml <span class="hljs-comment"># 就是使用记事本打开文件</span><br></code></pre></td></tr></table></figure><p>当然上述操作完全可以在资源管理器中进行，如果你实在不习惯命令行。</p><p>以及，在资源管理器的某个位置打开终端，cmd同理：</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/newimage-2.webp" alt="打开powershell"></p><p>如果你配置过右键菜单，也可以这样打开</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/new818ea2eebe43fac8e7295c56f1bbad91.webp" alt="右键菜单"></p><h4 id="compose部署-alist"><a href="#compose部署-alist" class="headerlink" title="compose部署 alist"></a>compose部署 alist</h4><p>现在，我在Docker目录下新建了一个alist-2的目录，并在其中新建了一个docker-compose.yml文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 在执行命令前，我位于 xxx/Docker</span><br>mkdir alist<span class="hljs-literal">-2</span><br><span class="hljs-built_in">cd</span> alist<span class="hljs-literal">-2</span><br><span class="hljs-built_in">ni</span> docker<span class="hljs-literal">-compose</span>.yml<br>notepad docker<span class="hljs-literal">-compose</span>.yml<br></code></pre></td></tr></table></figure><p>现在我们应该已经成功使用记事本打开了一个文件</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/newimage-3.webp" alt="打开记事本"></p><p>接下来，去alist文档里把它的<a href="https://alist.nn.ci/guide/install/docker.html#release-version">示例文件</a>内容复制下来</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/newimage-4.webp" alt="复制配置"></p><p>粘贴，保存</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/newimage-5.webp" alt="保存配置"></p><p>不过这里还没有结束，我们需要修改一下<code>volumes</code>词条，将数据目录换成我们需要的(以及，UID和GID实际上不应该被设置为0，这意味着以root身份运行容器，带来安全隐患，不过目前我们不考虑这些)</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/newimage-6.webp" alt="修改volumes配置"></p><p>我的习惯是小的数据&#x2F;配置文件直接放在当前目录下，这里 <code>&#39;./data&#39;</code> 意思是 当前目录下，data文件夹；整体的意思是：将当前目录下data文件夹同容器内<code>/opt/alist/data</code>两个文件夹进行绑定，可以理解为它俩现在是同一个东西了。</p><p>现在让我们回到终端，然后执行</p><p><strong>这里注意，需要保证desktop运行在后台，因为它会开启守护进程，客户端通过与守护进程通讯才能完成容器的正常部署</strong></p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/newimage-8.webp" alt="启动alist容器"></p><p>可以看到非常快速的就启动了一个容器(这里快是因为我们之前已经下载过alist的镜像了)</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/newimage-9.webp" alt="data目录结构"></p><p>同时 <code>data</code> 文件夹下已经被<code>alist</code>写入了一些数据文件，不过初始密码是打印出来的，由于我们放在后台运行了，暂时看不到；(这里可以去desktop里喵一眼，或者第一次启动的时候不加-d参数，看到密码ctrl-c停止，然后再-d运行；不过这看起来很蠢，但我们并不打算讨论进入容器内部操作的内容)</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/newimage-11.webp" alt="喵~"></p><p>然后就可以登录，并在网页内修改密码和权限…</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/newimage-12.webp" alt="alist登录页面"></p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/newimage-13.webp" alt="alist设置页面"></p><p>如果我们不再需要这个服务，直接关闭即可</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/newimage-14.webp" alt="停止alist容器"></p><h4 id="compose部署-emby"><a href="#compose部署-emby" class="headerlink" title="compose部署 emby"></a>compose部署 emby</h4><p>在部署<code>alist</code>时我们提供了比较细致的图文，后续的例子不会这么琐碎了，只会在关键位置说明；</p><p>这个例子中我们部署<code>emby</code>，这是家庭影音软件中的佼佼者。</p><p>我们还是直接抄别人的配置，这是镜像提供方的一个<a href="https://docs.linuxserver.io/images/docker-emby/#docker-compose-recommended-click-here-for-more-info">案例</a></p><p>这里我稍加修改(仅作一个运行展示，一些细节需要自定义)</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/newimage-16.webp" alt="修改emby配置"></p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/newimage-17.webp" alt="启动emby容器"></p><p>然后在本机8096端口即可享受服务</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/newimage-18.webp" alt="emby开始页面"></p><p>稍加配置，就可以享受emby提供的本地视频管理服务~（这里为了速度我配置乱选的，它自动刮削错了，而且我本地没有合适的视频文件，只从qq聊天记录里翻出来茶佬的一个录屏…</p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/newimage-19.webp" alt="emby效果"></p><p>总之服务很轻松的跑起来了（虽然emby并不需要docker部署，而且安装也很简单，但是这里只是举个例子，而且这种脚本化的部署非常适合服务器，我的emby就是跑在docker里的，主要是怕他到处拉屎</p><h4 id="compose部署-Calibra-web"><a href="#compose部署-Calibra-web" class="headerlink" title="compose部署 Calibra-web"></a>compose部署 Calibra-web</h4><p>请参考官方仓库 <a href="https://github.com/janeczku/calibre-web">calibre-web</a></p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-31.webp" alt="alt text"></p><p><del>不过官方的配置文件有个小坑，你最好提前准备一个<code>calibra</code>的数据库文件丢进去，具体使用的时候就知道是什么意思了，你也可以在issue里看到这个问题以及一些处理方法，我的建议是直接使用自己calibra的书库</del></p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-32.webp" alt="alt text"></p><p><img src="https://cdn.jsdelivr.net/gh/var-kong/picx-images-hosting@master/blog/202403/docker/image-33.webp" alt="alt text"></p><h3 id="好玩的项目"><a href="#好玩的项目" class="headerlink" title="好玩的项目"></a>好玩的项目</h3><p>使用<code>docker</code>的一大便利就是，哪怕完全不懂也可以轻松部署大量优秀的开(闭)源项目，而且不影响本机的正常使用，你要做的就是copy，稍微根据提示修改一下yml，然后 <code>docker compose up -d</code>，当然前提是你的电脑有足够的配置……</p><p>回归正题，有哪些<del>好玩</del>的项目：</p><p>Wait …</p>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地资源管理方案 -- 视频篇</title>
    <link href="/2024/03/manager-videos/"/>
    <url>/2024/03/manager-videos/</url>
    
    <content type="html"><![CDATA[<h1 id="本地资源管理方案-–-视频篇"><a href="#本地资源管理方案-–-视频篇" class="headerlink" title="本地资源管理方案 – 视频篇"></a>本地资源管理方案 – 视频篇</h1><p>视频分类：</p><ul><li>电影</li><li>动漫</li><li>JAV</li><li>电视剧</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在几类资源中，视频是相对比较容易管理的，这得益于成熟的软件体系和<del>商业化支持</del>；主要还是因为视频管理需求大，就会有很多人自己开发或者商业公司参与。常规(音)视频管理软件<del>御三家</del>：<a href="https://jellyfin.org/">Jellyfin</a>、<a href="https://emby.media/">Emby</a>、<a href="https://www.plex.tv/">Plex</a>. 本文也主要借助这三个软件，当然特殊的还是得特殊对待o(<em>￣▽￣</em>)ブ</p><p>与管理绕不开的就是<a href="https://zh.wikipedia.org/wiki/%E5%85%83%E6%95%B0%E6%8D%AE">元数据</a>的获取，一般称这种行为为刮削。仅仅播放显然是不能满足我们的需求的，我们还需要视频的各种信息(如果存在的话)，诸如演员、介绍、评分，以及字幕、相关的视频、图片等多种信息。这看起来不是一件容易做到的事情，但是好在我们有热心的朋友和还算和蔼可亲的商人们。</p><p>关于视频的分类，我主要是按照内容，分了4类 <code>电影</code> <code>动漫</code> <code>JAV</code> <code>电视剧</code>，以及它们的子类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>|-- Animate<br>|   |-- Adult <span class="hljs-comment"># 里番</span><br>|   `-- Normal<br>|-- Jav<br>|   |-- Mixed<br>|   `-- Serial <span class="hljs-comment"># 成系列的</span><br>|-- Movie<br>|   |-- Animate <span class="hljs-comment"># 动漫电影分到这里了</span><br>|   `-- Normal<br>`-- Tv <span class="hljs-comment"># tv剧在类别上不用细分了</span><br></code></pre></td></tr></table></figure><p>看名字应该比较清楚了，这样分类主要是方便隔离文件，防止出现一些尴尬的情况 ,,ԾㅂԾ,,</p><p>接下来就是具体的实现方式了。</p><h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><p>针对电影，我只在 <code>Emby</code>和 <code>Jellyfin</code> 中做选择，前者是曾经的开源项目后走向商业，后者是前者开源遗产的继承与发展。<code>Emby</code>作为可以免费使用的会员制商业软件，有着比较精致的UI界面和稳定的社区支持，对开源和客制化没啥追求的一般选 <code>Emby</code> 即可；</p><h2 id="动漫"><a href="#动漫" class="headerlink" title="动漫"></a>动漫</h2><h2 id="JAV"><a href="#JAV" class="headerlink" title="JAV"></a>JAV</h2><h2 id="电视剧"><a href="#电视剧" class="headerlink" title="电视剧"></a>电视剧</h2>]]></content>
    
    
    
    <tags>
      
      <tag>管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地资源管理方案 -- 概述</title>
    <link href="/2024/03/local-resource-management/"/>
    <url>/2024/03/local-resource-management/</url>
    
    <content type="html"><![CDATA[<h1 id="本地资源管理方案-—-概述"><a href="#本地资源管理方案-—-概述" class="headerlink" title="本地资源管理方案 — 概述"></a>本地资源管理方案 — 概述</h1><p><img src="https://github.com/var-kong/picx-images-hosting/raw/master/blog/files-struction.webp" alt="文件结构"></p><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>我自始至终相信互联网的内涵就是开放与自由，摆脱了传统媒介的限制，真正的将知识同全人类共享。但是在今天，以自由为内核的互联网在走向封闭。搜索引擎所能检索到的有价值的信息在变少，更多的网站选择收拢用户。做如此描述并非是在怀念那个盗版横行的时代，只是互联网作为一个自由的工具，早已被凌驾其之上的，所谓意识，所谓资本所操纵着。</p><p>没有商业化，就没有现在如此繁盛的互联网。但是过度的商业化很大程度上污染了互联网，它将有价值的信息藏匿在资本背后，同时又不遗余力的阻碍着有效信息的传递。这里我没有污名化商业行为的意思，互联网只是一个工具，它的内涵要求它对任何组织或个人保持开放，而不受其背后的种族、宗教或意识形态的影响。只不过商业本身所裹挟的逐利性同互联网最底层的开放天生相悖，结果就是最强大的骑士和恶龙合体了……</p><p>当然，不能将这种现象归咎于任何实体对象，因为互联网只是一个工具，它所展现的精神、价值完全取决于使用或者说操控互联网的人。我所怀念的，只是它在诞生之初所展现的，并且现在仍不失其光彩的，那种作为人类特有的，某种无法言表的，自由思想。</p><p>必须要说明的是，我无意将本文发展成一篇稍带怨恨意味的理想主义檄文，只是一个引子，为了方便我后面以自由精神的大义来规避版权问题罢了(不是)</p><h2 id="本地资源"><a href="#本地资源" class="headerlink" title="本地资源"></a>本地资源</h2><p>当互联网的资源不再能被轻易地获得，有价值的信息被藏匿于大量垃圾、陷阱之中并无法保持其长效性时，作为个人的我们就需要有意识地去筛选，并在必要时存储需要的信息。</p><p>信息检索与获取能力不在本系列讨论范围，目前只关心如何管理已经存储在本地的各种类型的文件，或者说资源。</p><p>当然，这只是我个人的使用方案，仅作记录；我将资源大致按如下结构划分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>|-- Books<br>|   |-- Comic<br>|   |-- Ebook<br>|   `-- Magazine<br>|-- Musics<br>|   |-- Album<br>|   |-- BGM<br>|   |-- List<br>|   `-- Singer<br>|-- Pictures<br>|   |-- Anime<br>|   |-- Meme<br>|   |-- NSFW<br>|   `-- Wallpaper<br>`-- Videos<br>    |-- Animate<br>    |   |-- Adult<br>    |   `-- Normal<br>    |-- Jav<br>    |   |-- Mixed<br>    |   `-- Serial<br>    |-- Movie<br>    |   |-- Animate<br>    |   `-- Normal<br>    `-- Tv<br></code></pre></td></tr></table></figure><p>整体上，包括有 <code>Books</code> <code>Musics</code> <code>Videos</code> <code>Pictures</code> 这4类，每类下面再按照 用途&#x2F;格式&#x2F;类型 继续划分</p><h2 id="管理方案"><a href="#管理方案" class="headerlink" title="管理方案"></a>管理方案</h2><p>实际上，资源分类是<del>相对容易</del>的事情，但是如何根据资源类型选择合适的管理方案，以相对平滑的流程，满足特定的需求，是比较繁琐的。本系列就是针对不同情况的讨论，仅作个人使用的一种记录与分享。大部分情况下，我都会选择开源的项目，<del>或者某些曾经开源了又跑路的</del>；</p><p>再次声明，如何合理地检索需要的资源并合理地存储，事关个人的使用习惯，无意干涉。</p>]]></content>
    
    
    
    <tags>
      
      <tag>软件</tag>
      
      <tag>管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/03/hello-world/"/>
    <url>/2024/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
